# Функция принимает как аргументы два массива и другую функцию
def bopoh(arr, arr2, some_fn):
    # Рекурсивно перебирает все возможные комбинации. Как аргументы принимает массив и счетчик, изначально равный длине
    # массива
    def combinations(a, lenght):
        # Если счетчик равен 1, перебор закончен
        if lenght == 1:
            # Скармливает результат от 1 элемента до n
            for x in range(1, len(a) + 1):
                temp = str(arr[len(arr) - 1])
                string = str(".".join(arr[:len(arr) - 1]) + "." + ".".join(a[:x]) + "." + temp)
                print(string)
                # если функция возвращает True, рекурсия прерывается и возвращается результат
                if some_fn(string):
                    print("Here!")
                    return string
            # возвращаение на предыдущий слой рекурсии
            return
        # рекурсивно вызываем функцию пока есть что переставлять, и уменьшаем счетчик на 1
        for i in range(lenght):
            # Записываем то, что нам возвращает функция.
            k = combinations(a, lenght - 1)
            if type(k) != str:
                # Если функция возвращает None, счетчик четный - меняем местами первый и lenght-1 элемент
                if lenght % 2 == 0:
                    a[0], a[lenght - 1] = a[lenght - 1], a[0]
                # Если счетчик нечетный - меняем местами элементы i и lenght -1
                else:
                    a[i], a[lenght - 1] = a[lenght - 1], a[i]
            else:
                # Если функция вернула строку - возвращаем результат
                return k
    # записываем и возвращаем результат функции combinations. Если нужной комбинации не найдено - возвращаем "Not found"
    result = combinations(arr2, len(arr2))
    if result:
        return result
    return "Not found"


array = ["a", "b", "c"]
array2 = ["d", "e", "f", "g"]


def testFn(x=""):
    if len(x) == 13:
        return True
    else:
        return False


print(bopoh(array, array2, testFn))
